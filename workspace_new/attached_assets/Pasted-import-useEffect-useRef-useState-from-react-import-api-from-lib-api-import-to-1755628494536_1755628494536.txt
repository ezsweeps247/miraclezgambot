import { useEffect, useRef, useState } from "react";
import { api } from "../lib/api";
import { toChance, toMultiplier } from "../lib/format";

type Props = { setLastHit: (x: number) => void; onBalance: (b: number) => void; };

type Action =
  | { type: "none" }
  | { type: "reset" }
  | { type: "increase_pct"; value: number }
  | { type: "increase_flat"; value: number }
  | { type: "multiply"; value: number };

export default function LimboAuto({ setLastHit, onBalance }: Props) {
  const [baseAmount, setBaseAmount] = useState(1);
  const [amount, setAmount] = useState(1);
  const [mult, setMult] = useState(2.0);
  const [chance, setChance] = useState(toChance(2.0));
  const [link, setLink] = useState(true);

  const [numBets, setNumBets] = useState(0); // 0 = infinite
  const [onWin, setOnWin] = useState<Action>({ type: "none" });
  const [onLoss, setOnLoss] = useState<Action>({ type: "none" });
  const [stopProfit, setStopProfit] = useState(0);
  const [stopLoss, setStopLoss] = useState(0);

  const [running, setRunning] = useState(false);
  const sessionStartBalance = useRef<number | null>(null);
  const stopFlag = useRef(false);

  useEffect(() => { setAmount(baseAmount); }, [baseAmount]);

  const setMultLinked = (m: number) => {
    setMult(m);
    if (link) setChance(toChance(m));
  };
  const setChanceLinked = (c: number) => {
    setChance(c);
    if (link) setMult(toMultiplier(c));
  };

  const applyAction = (current: number, action: Action, base: number) => {
    switch (action.type) {
      case "none": return current;
      case "reset": return base;
      case "increase_pct": return current * (1 + action.value / 100);
      case "increase_flat": return current + action.value;
      case "multiply": return current * action.value;
    }
  };

  const start = async () => {
    if (running) return;
    setRunning(true);
    stopFlag.current = false;
    sessionStartBalance.current = (await api.get<{ balance: number }>("/users/me")).balance;
    setAmount(baseAmount);

    let i = 0;
    while (!stopFlag.current && (numBets === 0 || i < numBets)) {
      // place bet
      const r = await api.post("/bets/roll", { amount, targetMultiplier: mult });
      setLastHit(r.hitMultiplier);
      onBalance(r.balance);

      // compute session P/L against starting balance
      const startBal = sessionStartBalance.current!;
      const sessionPnL = r.balance - startBal;

      // check stop conditions
      if (stopProfit > 0 && sessionPnL >= stopProfit) break;
      if (stopLoss > 0 && -sessionPnL >= stopLoss) break;

      // choose next amount based on win/loss
      const won = r.win === 1;
      const action = won ? onWin : onLoss;
      const next = applyAction(amount, action, baseAmount);
      setAmount(next);
      i++;

      await new Promise(res => setTimeout(res, 200)); // 200ms spacing
    }
    setRunning(false);
  };

  const stop = () => { stopFlag.current = true; };

  return (
    <div className="space-y-3">
      {/* Bet amount */}
      <div>
        <div className="text-xs opacity-70 mb-1">Bet Amount</div>
        <div className="flex gap-2">
          <input className="input" type="number" step="0.00000001"
                 value={baseAmount} onChange={e => setBaseAmount(Number(e.target.value))} />
          <span className="text-xs self-center opacity-60">Base</span>
        </div>
        <div className="text-[11px] mt-1 opacity-60">Current: {amount.toFixed(8)} Credits</div>
      </div>

      {/* Number of bets */}
      <div>
        <div className="text-xs opacity-70 mb-1">Number of Bets</div>
        <div className="flex gap-2">
          <input className="input" type="number" min={0} value={numBets} onChange={e => setNumBets(Number(e.target.value))} />
          <span className="kbd self-center">âˆž if 0</span>
        </div>
      </div>

      {/* On Win / On Loss */}
      <div className="grid grid-cols-2 gap-3">
        <AutoAction label="On Win" action={onWin} setAction={setOnWin} />
        <AutoAction label="On Loss" action={onLoss} setAction={setOnLoss} />
      </div>

      {/* Stop limits */}
      <div className="grid grid-cols-2 gap-3">
        <div>
          <div className="text-xs opacity-70 mb-1">Stop on Profit</div>
          <input className="input" type="number" min={0} value={stopProfit} onChange={e => setStopProfit(Number(e.target.value))} />
        </div>
        <div>
          <div className="text-xs opacity-70 mb-1">Stop on Loss</div>
          <input className="input" type="number" min={0} value={stopLoss} onChange={e => setStopLoss(Number(e.target.value))} />
        </div>
      </div>

      {/* Controls */}
      <div className="flex gap-2">
        {!running ? (
          <button onClick={start} className="button w-full">Start Autobet</button>
        ) : (
          <button onClick={stop} className="button w-full">Stop</button>
        )}
      </div>

      {/* Bottom inputs (Multiplier/Chance) */}
      <div className="border-t border-[#1f2430] pt-3 mt-3">
        <div className="grid grid-cols-2 gap-3">
          <div>
            <div className="text-xs opacity-70 mb-1">Multiplier</div>
            <div className="relative">
              <input className="input" type="number" step="0.01" min={1.01}
                     value={mult} onChange={e => setMultLinked(Number(e.target.value))} />
              <button
                onClick={() => setLink(v => !v)}
                className={"absolute right-2 top-1/2 -translate-y-1/2 text-xs opacity-70 " + (link ? "underline" : "")}
              >
                {link ? "linked" : "free"}
              </button>
            </div>
          </div>
          <div>
            <div className="text-xs opacity-70 mb-1">Chance</div>
            <div className="relative">
              <input className="input" type="number" step="0.01" min={0.01} max={99.0}
                     value={chance} onChange={e => setChanceLinked(Number(e.target.value))} />
              <div className="absolute right-2 top-1/2 -translate-y-1/2 text-xs opacity-70">%</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

function AutoAction({
  label, action, setAction
}: { label: string; action: Action; setAction: (a: Action) => void }) {
  const [kind, setKind] = useState<Action["type"]>(action.type);
  const [value, setValue] = useState<number>((action as any).value ?? 0);

  useEffect(() => {
    if (kind === "none" || kind === "reset") setAction({ type: kind });
    else if (kind === "increase_pct") setAction({ type: "increase_pct", value });
    else if (kind === "increase_flat") setAction({ type: "increase_flat", value });
    else if (kind === "multiply") setAction({ type: "multiply", value });
  }, [kind, value]);

  return (
    <div>
      <div className="text-xs opacity-70 mb-1">{label}</div>
      <div className="flex gap-2">
        <select className="input" value={kind} onChange={e => setKind(e.target.value as any)}>
          <option value="none">No change</option>
          <option value="reset">Reset to base</option>
          <option value="increase_pct">Increase by %</option>
          <option value="increase_flat">Increase by flat</option>
          <option value="multiply">Multiply by</option>
        </select>
        {!(kind === "none" || kind === "reset") && (
          <input className="input" type="number" value={value} onChange={e => setValue(Number(e.target.value))} />
        )}
      </div>
    </div>
  );
}
