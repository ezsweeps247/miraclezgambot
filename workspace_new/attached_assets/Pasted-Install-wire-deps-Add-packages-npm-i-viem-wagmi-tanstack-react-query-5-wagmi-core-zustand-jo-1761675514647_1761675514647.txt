Install & wire deps

Add packages:

npm i viem wagmi @tanstack/react-query@^5 @wagmi/core zustand jotai
npm i -D abitype hardhat @nomicfoundation/hardhat-toolbox dotenv ts-node
npm i @openzeppelin/contracts


Keep existing deps. Create /contracts, /server/web3, /shared/web3, /client/src/web3.

.env (both local & Railway)
CHAIN_ID=8453                        # e.g., Base mainnet (use 84532 for Base Sepolia)
RPC_URL=https://base-sepolia.g.alchemy.com/v2/<key>
WALLET_PRIVATE_KEY=0x...             # deployer/signing key (never expose to client)
NFT_COLLECTION_NAME=BUUNIX Player Pass
NFT_COLLECTION_SYMBOL=BNX
NFT_BASE_URI=https://cdn.buunix.app/nft/pass/metadata/
NFT_CONTRACT_ADDRESS=                # filled after deploy
SIGNER_DOMAIN_NAME=BUUNIX-NFT
SIGNER_DOMAIN_VERSION=1

1) Smart contract (Solidity) — ERC-1155 PlayerPass

Create /contracts/PlayerPass1155.sol:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract PlayerPass1155 is ERC1155, Ownable {
    using ECDSA for bytes32;

    string public name;
    string public symbol;
    mapping(address => bool) public trustedSigners; // backend signers for allow/achievement mints
    mapping(bytes32 => bool) public used;           // replay protection (salt)

    event TrustedSigner(address signer, bool active);

    constructor(
        string memory _name,
        string memory _symbol,
        string memory baseURI,
        address owner_
    ) ERC1155(baseURI) Ownable(owner_) {
        name = _name; symbol = _symbol;
    }

    function setURI(string memory newuri) external onlyOwner { _setURI(newuri); }

    function setTrustedSigner(address signer, bool active) external onlyOwner {
        trustedSigners[signer] = active;
        emit TrustedSigner(signer, active);
    }

    // EIP-712-like off-chain mint authorization (simple ECDSA)
    function mintWithSig(
        address to,
        uint256 id,
        uint256 amount,
        bytes32 salt,
        bytes calldata sig
    ) external {
        bytes32 digest = keccak256(abi.encodePacked(address(this), "MINT", to, id, amount, salt)).toEthSignedMessageHash();
        address signer = digest.recover(sig);
        require(trustedSigners[signer], "invalid signer");
        require(!used[salt], "salt used");
        used[salt] = true;
        _mint(to, id, amount, "");
    }

    function burn(address from, uint256 id, uint256 amount) external {
        require(from == msg.sender || isApprovedForAll(from, msg.sender), "not approved");
        _burn(from, id, amount);
    }
}

Hardhat minimal

/contracts/hardhat.config.ts

import "dotenv/config";
import "@nomicfoundation/hardhat-toolbox";
import { HardhatUserConfig } from "hardhat/config";

const config: HardhatUserConfig = {
  solidity: "0.8.24",
  networks: {
    baseSepolia: { url: process.env.RPC_URL!, accounts: [process.env.WALLET_PRIVATE_KEY!] }
  }
};
export default config;


scripts/deploy.ts

import { ethers } from "hardhat";
(async () => {
  const C = await ethers.getContractFactory("PlayerPass1155");
  const c = await C.deploy(
    process.env.NFT_COLLECTION_NAME!,
    process.env.NFT_COLLECTION_SYMBOL!,
    process.env.NFT_BASE_URI!,
    (await ethers.getSigners())[0].address
  );
  await c.waitForDeployment();
  console.log("NFT_CONTRACT_ADDRESS=", await c.getAddress());
})();


Task: add npm run deploy:sepolia → hardhat run scripts/deploy.ts --network baseSepolia

2) Database (Drizzle) additions

Add to @shared/schema.ts:

export const wallets = pgTable("wallets", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  chainId: integer("chain_id").notNull(),
  address: varchar("address", { length: 64 }).notNull().unique(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const nftMints = pgTable("nft_mints", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  address: varchar("address", { length: 64 }).notNull(),
  tokenId: integer("token_id").notNull(),   // 1=PlayerPass, 2=VIP, 100~ tickets/loot
  amount: integer("amount").notNull(),
  salt: varchar("salt", { length: 66 }).notNull().unique(),
  txHash: varchar("tx_hash", { length: 80 }),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const nftRewards = pgTable("nft_rewards", {
  id: serial("id").primaryKey(),
  externalPlayerId: varchar("external_player_id", { length: 128 }),
  tokenId: integer("token_id").notNull(),
  reason: varchar("reason", { length: 256 }),
  scReward: numeric("sc_reward"), // optional stake credit drop on mint
  gcReward: numeric("gc_reward"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});


Run npm run db:push.

3) Backend Web3 layer (Express)

Create /server/web3/viem.ts:

import { createPublicClient, createWalletClient, http, parseAbiItem, Hex, Address } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { baseSepolia } from "viem/chains";

export const CHAIN = baseSepolia; // param by CHAIN_ID if needed

export const publicClient = createPublicClient({ chain: CHAIN, transport: http(process.env.RPC_URL!) });

const account = privateKeyToAccount(process.env.WALLET_PRIVATE_KEY as Hex);
export const walletClient = createWalletClient({ account, chain: CHAIN, transport: http(process.env.RPC_URL!) });

// ECDSA offchain signer (node private key)
import crypto from "crypto";
export function signMint(to: Address, tokenId: bigint, amount: bigint, salt: Hex) {
  const msg = Buffer.concat([
    Buffer.from("MINT"),
    Buffer.from(to.slice(2), "hex"),
    Buffer.from(tokenId.toString()),
    Buffer.from(amount.toString()),
    Buffer.from(salt.slice(2), "hex")
  ]);
  const hash = crypto.createHash("sha256").update(Buffer.concat([Buffer.from(process.env.NFT_CONTRACT_ADDRESS!), msg])).digest();
  const sig = crypto.sign(null, hash, Buffer.from((process.env.WALLET_PRIVATE_KEY as string).slice(2), "hex")); // illustrative; use ethers-like ECDSA if preferred
  return "0x" + sig.toString("hex") as Hex;
}


(You can alternatively build the exact toEthSignedMessageHash style using ethers or viem’s hashMessage + signMessage with the same private key. Ensure the contract’s expected digest matches.)

NFT API routes

Create /server/api/nft.ts and mount at /api/nft:

POST /link-wallet → { userId, address, chainId } → inserts into wallets.

GET /config → returns { chainId, contract: NFT_CONTRACT_ADDRESS, baseUri }.

POST /mint/pass → body { userId | externalPlayerId, address?, tokenId=1, amount=1 }

resolve address (linked wallet or provided)

create salt = 0x<random32>; sign with signMint

store row in nft_mints

return { address, tokenId, amount, salt, signature } (client calls contract mintWithSig)

POST /reward/after-mint → optional hook to drop SC/GC via existing credits/points routers when nft_rewards policy matches tokenId.

GET /holds/:address → read balances for token IDs (via publicClient.readContract).

Tie into your webhooks: on game.ended (already exists), optionally award a ticket NFT (tokenId=100+) when highestRow or blocksStacked meets thresholds.

4) Client: wallet connect + mint flow

Create /client/src/web3/wallet.tsx:

Use wagmi + viem for wallet connection (Injected/WalletConnect optional).

Provide hooks: useChainConfig(), useLinkWallet(), useMintPass(), useBalances().

/client/src/components/NFTPane.tsx:

Shows “Link Wallet”, “Mint Player Pass (GC bonus)”.

After mint, call /api/nft/reward/after-mint to credit GC.

Contract ABI: generate minimal ABI for mintWithSig, uri, balanceOf.

export const playerPassAbi = [
  { "inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"bytes","name":"sig","type":"bytes"}], "name":"mintWithSig","outputs":[], "stateMutability":"nonpayable","type":"function" },
  { "inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"uri","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function" },
  { "inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function" }
] as const;


Mount an NFT tab in your existing UI (keep modern styling). Show:

Linked wallet address

Pass balance

Buttons: Mint Pass, View on explorer, Copy verify payload (salt + signature)

5) Utility design (how NFTs affect gameplay — SC/GC only)

Implement off-chain utilities (no cash language):

Player Pass (id=1) → +5% GC on wins; +2% SC reload bonus (apply via your credit/points routers).

VIP Pass (id=2) → Rakeback multiplier, priority support tag.

Event Ticket (id>=100) → grants access to special Play-to-Win rooms; burn on entry.

Achievement Badges (id 10–50) → cosmetic; auto-mint via signed server authorizations.

Hook points:

In /server/api/game/sessions/:sessionToken/end after score finalize, look up wallets for externalPlayerId, query balanceOf → compute bonus; call /api/game/points/award or /api/game/credits/load as appropriate.

6) Security & verification

Never leak WALLET_PRIVATE_KEY to the client. Sign in server only.

Add replay protection via salt (stored & checked on-chain; we also store in DB).

Add rate-limit on /api/nft/mint and IP throttling.

Create /client/src/pages/pf-verify-nft.tsx showing how to validate the signature and on-chain used[salt].

7) Integration with existing routes

Mount nftRouter in registerRoutes:

import nftRouter from "./api/nft";
app.use("/api/nft", nftRouter);


When delivering game feed WS events, include hasPass:boolean in payload (looked up once per session).

8) DX & scripts

Add scripts:

"deploy:sepolia": "hardhat run contracts/scripts/deploy.ts --network baseSepolia",
"nft:set-signer": "tsx contracts/scripts/setSigner.ts"


setSigner.ts calls setTrustedSigner(<backendSigner>, true).

9) Acceptance checklist

 Contract deployed; NFT_CONTRACT_ADDRESS set in env.

 /api/nft/config, /link-wallet, /mint/pass, /holds/:address live & typed.

 Client can connect wallet, link account, mint with server signature, and see balances.

 Game end flow recognizes pass and applies SC/GC bonuses via your existing credits/points endpoints.

 No real-money text anywhere; all amounts in SC/GC.

 Replay-safe signature mints; salts stored; endpoint rate-limited.

 Works on mobile + desktop; modern UI.

10) Bonus (if time)

Add allowlist CSV import for presale mints (server signs only listed addresses).

Add NFT marketplace metadata with dynamic attributes (tier, perk).

Add Burn-to-Enter tourneys: burn ticket id=101 to join event.

Build now. Create all files, wire routes, update UI, and print deploy address + test mint instructions.